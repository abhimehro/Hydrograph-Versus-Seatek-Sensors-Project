# Refactored version
import re
import sys
from typing import Optional
from .util import col, line, lineno, _collapse_string_to_ranges
from .unicode import pyparsing_unicode as ppu


class ExceptionWordUnicode(ppu.Latin1, ppu.LatinA, ppu.LatinB, ppu.Greek, ppu.Cyrillic):
    pass


ALPHANUM_RANGES = _collapse_string_to_ranges(ExceptionWordUnicode.alphanums)
EXCEPTION_WORD_REGEX = re.compile(f"([{ALPHANUM_RANGES}]{1, 16})|.")


class ParseBaseException(Exception):
    """Base exception class for all parsing runtime exceptions."""

    def __init__(
            self,
            input_string: str,
            location: int = 0,
            message: Optional[str] = None,
            element=None
    ):
        self.loc = location
        self.msg = input_string if message is None else message
        self.pstr = "" if message is None else input_string
        self.parser_element = self.parserElement = element
        self.args = (input_string, location, message)

    @staticmethod
    def explain_exception(exc, depth: int = 16) -> str:
        """
        Translate the Python traceback into a list of pyparsing expressions that caused the exception.
        """
        import inspect
        from .core import ParserElement

        if depth is None:
            depth = sys.getrecursionlimit()

        result = []
        if isinstance(exc, ParseBaseException):
            result.append(exc.line)
            result.append(" " * (exc.column - 1) + "^")

        result.append(f"{type(exc).__name__}: {exc}")
        callers = inspect.getinnerframes(exc.__traceback__, context=depth)

        seen = set()
        for frame in callers[-depth:]:
            frame_locals = frame[0].f_locals
            parser_self = frame_locals.get("self")

            if isinstance(parser_self, ParserElement):
                if frame[0].f_code.co_name not in ("parseImpl", "_parseNoCache"):
                    continue
                if id(parser_self) in seen:
                    continue
                seen.add(id(parser_self))
                result.append(f"{type(parser_self).__module__}.{type(parser_self).__name__} - {parser_self}")
            elif parser_self is not None:
                result.append(f"{type(parser_self).__module__}.{type(parser_self).__name__}")
            else:
                code_name = frame[0].f_code.co_name
                if code_name not in ("wrapper", "<module>"):
                    result.append(code_name)

            depth -= 1
            if depth <= 0:
                break

        return "\n".join(result)

    @classmethod
    def _from_exception(cls, parse_exception):
        """Factory method to simplify creating one type of ParseException from another."""
        return cls(parse_exception.pstr, parse_exception.loc, parse_exception.msg, parse_exception.parserElement)

    @property
    def line(self) -> str:
        """Return the line of text where the exception occurred."""
        return line(self.loc, self.pstr)

    @property
    def lineno(self) -> int:
        """Return the 1-based line number of the text where the exception occurred."""
        return lineno(self.loc, self.pstr)

    @property
    def column(self) -> int:
        """Return the 1-based column position on the line where the exception occurred."""
        return col(self.loc, self.pstr)

    def _get_found_str(self) -> str:
        """Helper to determine the string found at the exception location."""
        if self.loc >= len(self.pstr):
            return ", found end of text"
        match = EXCEPTION_WORD_REGEX.match(self.pstr, self.loc)
        found = match.group(0) if match else self.pstr[self.loc:self.loc + 1]
        return f", found {repr(found)}".replace(r"\\", "\\")

    def __str__(self) -> str:
        found_str = self._get_found_str() if self.pstr else ""
        return f"{self.msg}{found_str}  (at char {self.loc}), (line:{self.lineno}, col:{self.column})"

    def __repr__(self):
        return str(self)

    def mark_input_line(self, marker_string: Optional[str] = None, *, default_marker_string=">!<") -> str:
        """
        Extracts the exception line from the input string and marks the location of the exception with a symbol.
        """
        marker_string = marker_string if marker_string is not None else default_marker_string
        column_position = self.column - 1

        line_content = (
                self.line[:column_position] + marker_string + self.line[column_position:]
        )
        return line_content.strip()

    def explain(self, depth: int = 16) -> str:
        """Wrapper for explain_exception to translate tracebacks into diagnostic summaries."""
        return self.explain_exception(self, depth)

    # Alias for backward compatibility
    markInputline = mark_input_line
