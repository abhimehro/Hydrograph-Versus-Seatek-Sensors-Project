import os
import sys
from collections.abc import Iterable
from enum import Enum
from typing import Union, Callable, Any, Optional
from .results import ParseResults

# Constants
WARN_OPTION_SEPARATOR = "::::"
PY_PARSING_MODULE = "pyparsing"


# Exception Classes
class SpecificException1(Exception):
    pass


class SpecificException2(Exception):
    pass


# Compatibility Configuration
class CompatibilityConfig:
    """Cross-version compatibility configuration for pyparsing features."""
    collect_all_and_tokens = True

    @classmethod
    def get_all_names(cls) -> list[str]:
        return [
            name for name in cls.__dict__
            if not name.startswith("_") and not callable(getattr(cls, name))
        ]


# Diagnostic Configuration
class DiagnosticConfig:
    """Global diagnostic configuration with warnings and debug options."""
    _WARN_FLAGS = {
        # Warning flags as constants
    }

    @classmethod
    def enable_all_warnings(cls) -> None:
        for key in cls._WARN_FLAGS:
            if key.startswith("warn"):
                cls._WARN_FLAGS[key] = True

    @classmethod
    def set_warning_flag(cls, flag_name: str, value: bool) -> None:
        cls._WARN_FLAGS[flag_name] = value

    @property
    def warning_flags(self):
        return self._WARN_FLAGS


# Enum for Diagnostics
class Diagnostics(Enum):
    WARN_MULTIPLE_TOKENS = 0
    ...


# Diagnostics Management
class DiagnosticsManager:
    """Manages enabling/disabling diagnostics."""

    @staticmethod
    def enable_diagnostic(diag_enum: Diagnostics) -> None:
        DiagnosticConfig.set_warning_flag(diag_enum.name.lower(), True)

    @staticmethod
    def disable_diagnostic(diag_enum: Diagnostics) -> None:
        DiagnosticConfig.set_warning_flag(diag_enum.name.lower(), False)

    @staticmethod
    def is_warning_enabled(cmd_line_warn_options: Iterable[str], warn_env_var: Optional[str]) -> bool:
        """Determine if warnings should be enabled based on command-line and environment."""

        def _parse_warn_option(option: str):
            parts = (option + WARN_OPTION_SEPARATOR).split(":")
            return parts[:5]

        enable = bool(warn_env_var)
        for warn_option in cmd_line_warn_options:
            warn_action, warn_message, warn_category, warn_module, _ = _parse_warn_option(warn_option)
            if not warn_action.lower().startswith("i") and (
                    not (warn_message or warn_category or warn_module) or warn_module == PY_PARSING_MODULE
            ):
                enable = True
            elif warn_action.lower().startswith("i") and warn_module in (PY_PARSING_MODULE, ""):
                enable = False
        return enable


# Enabling all warnings if system conditions are met
if DiagnosticsManager.is_warning_enabled(
        sys.warnoptions, os.environ.get("PYPARSINGENABLEALLWARNINGS")
):
    DiagnosticConfig.enable_all_warnings()

# Built-in single-argument functions eligible as parse actions
SINGLE_ARG_BUILTINS = {sum, len, sorted, reversed, list, tuple, set, any, all, min, max}

# Type alias
ParseAction = Union[
    Callable[[Any], Any],
    Callable[[ParseResults], Any],
    Callable[[int, ParseResults], Any],
    Callable[[str, int, ParseResults], Any],
]


class ParserElement:
    pass
